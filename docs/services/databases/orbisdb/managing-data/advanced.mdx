---
title: Advanced queries
description: Learn how to use advanced queries in OrbisDB.
---

By using PostgreSQL as our backing database engine, we get to leverage all the upsides already
included in its vast ecosystem. Unless otherwise stated, the below queries should be ran using the
OrbisDB SQL Editor.

## Joins

Relational data model, as the name suggests, often has data that relates to one another. This is the
core concept of relational databases and is an inevitable part of using a relational database - if
used correctly.

OrbisDB supports joins in Raw SQL and GraphQL query modes. The built-in query builder does not
support joins, yet.

Joins are often used with foreign keys and indexes. Here's a great
[visual guide to PostgreSQL joins](https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-joins/).

### `LEFT JOIN` example

This is a Raw SQL left join example. GraphQL handles joins implicitly.

```sql
SELECT
    table_a.column_a,
    table_b.column_b
FROM
    tableA
LEFT JOIN table_b
    ON table_a.column = table_b.column;
```

## Relations

### One-to-One

### One-to-Many

### Many-to-Many

### Foreign keys

### OrbisDB relations

## Views

You may end up running some queries which utilize things such as `JOIN`, filters, etc often. To
avoid writing them over and over again, PostgreSQL comes with built-in Views.

You can think of Views as _virtual tables_ that don't actually exist, but can be queried as such.
Views are queries that get executed _every time_ you use it. They are useful when complex relations
and aggregations need to be used. Views can be queried with all OrbisDB query methods the same way
any other table can.

Learn more about Views
[here](https://www.postgresqltutorial.com/postgresql-views/managing-postgresql-views/).

### Creating a `VIEW`

When creating a `VIEW`, you are really just naming your `SELECT` query.

```sql
CREATE VIEW view_name AS
	SELECT stream_id, controller FROM table_name;
```

### Deleting a `VIEW`

```sql
DROP VIEW IF EXISTS view_name;
```

### Materialized `VIEW`

Unlike default Views, Materialized Views aren't virtual and actually store the results of the query.
This can be useful for data that's not refreshed often as these views **do not refresh**
automatically.

Materialized Views are essentially tables that can't be directly modified, but instead rely on a
query to fetch and populate data.

Learn more about the caveats when using Materialized Views
[here](https://www.postgresqltutorial.com/postgresql-views/postgresql-materialized-views/).

#### Creating a `MATERIALIZED VIEW`

```sql
CREATE MATERIALIZED VIEW view_name AS
	SELECT stream_id, controller FROM table_name;
```

#### Refreshing a `MATERIALIZED VIEW`

```sql
REFRESH MATERIALIZED VIEW view_name;
```

#### Deleting a `MATERIALIZED VIEW`

```sql
DROP MATERIALIZED VIEW IF EXISTS view_name;
```

## Analyzing queries

Querying large and complex datasets can come with unexpected bottlenecks. The same is true for all
query types - `INSERT`, `UPDATE`, `SELECT` and `DELETE` alike.

PostgreSQL comes with a built in query analyzer that can be used to determine what's happening under
the hood when running queries. You're able to see the computation required, how many rows are
getting accessed and which indexes (if any) are being used.

### EXPLAIN queries

`EXPLAIN` can be used to determine the cost of a query **without executing it**. This is important
as you don't want to accidentally perform modifications on your database. The same applies for
expensive queries, as you don't want to overload a database that's used in production.

The results of `EXPLAIN` are _accurate enough_.

#### Example `ANALYZE` for an `INSERT`

```sql
EXPLAIN INSERT INTO table(id, name) VALUES(1, 'name');
```

### EXPLAIN ANALYZE queries

> ❗ Be careful when using `EXPLAIN ANALYZE` as you may end up modifying your database in unexpected
> ways.

`EXPLAIN ANALYZE` goes an extra step and actually **executes the query** in order to analyze it.
It's recommended you don't use it unless you know what you're doing.

It's best used with `SELECT` queries as the worst case scenario is extra load on your database.

#### Example `EXPLAIN ANALYZE` for a `SELECT`

```sql
EXPLAIN ANALYZE SELECT * FROM table;
```

## Indexes

When fetching data from a database, there's loads of planning happening in the background to
optimize and speed up the query. This is handled by the database, in our case PostgreSQL. By
default, the database engine would have to scan through _all_ the rows in your table to find the
ones that match your query.

This can get very computationally expensive as your database grows.

Indexes are the easiest way to improve `SELECT` performance. They are created on commonly filtered
columns and create a "cache" of values that can be accessed without scanning the entire table.

There are multiple types of indexes, but the default one is B-tree. Other commonly used indexes are
GIST and GIN indexes. You can find the full list of index types
[here](https://www.postgresql.org/docs/current/indexes-types.html).

OrbisDB creates 3 indexes on every table it creates:

- `stream_id` - Ceramic ID of the entry
- `controller` - data author, owner
- `indexed_at` - the timestamp when this entry has been indexed

### Creating an index

You're able to create new indexes directly from your OrbisDB SQL editor.

```sql
CREATE INDEX IF NOT EXISTS index_name ON table (columnName);
```

The above query will create a B-tree index on a `table`'s column named `columnName`.

### Deleting an index

```sql
DROP INDEX IF EXISTS index_name;
```

## Constraints

### Check

### Not NULL

### Unique

### Primary keys

> OrbisDB automatically assigns the Primary key to the `stream_id` column, as it knows upfront that
> the column only references a single data entry

Primary keys are a special `UNIQUE` constraint. They define a single unique constraint that can be
securely used to reference the row in other tables (as a Foreign Key).

There can only be _one_ Primary key per table. However, a Primary key can be composed of multiple
columns - composite Primary keys.

### Foreign keys

## Extensions

> Available extensions depend on your PostgreSQL hosting provider. Some extensions need to be built
> and don't come bundled with a default PostgreSQL installation.

PostgreSQL has an incredible ecosystem of extensions, allowing for advanced use-cases. These can be
as simple as statistics monitoring or as advanced as vector and columnar storage, full text search,
etc.

Check out an example catalogue of extensions
[here](https://gist.github.com/joelonsql/e5aa27f8cc9bd22b8999b7de8aee9d47).

### Enabling an extension

Enabling extensions is simple using our built-in SQL editor, as queries ran through it have write
access to your underlying database.

```sql
CREATE EXTENSION IF NOT EXISTS pg_trgm;
```

This statement will enable a trigram extension. It can be used for better keyword search and
similarity matching.

### Disabling an extension

```sql
DROP EXTENSION IF EXISTS pg_trgm;
```
