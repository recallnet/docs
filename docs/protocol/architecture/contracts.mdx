---
title: Contracts
description: The core building blocks for data exchange.
---

Recall's core functionality is built as a series of Wasm-based contracts that run on the Wasm
execution layer and are used to manage, query, and update the state of the subnet. In effect, the
Wasm runtime is responsible for executing the logic of the Recall protocol.

## Contract execution

The runtime executes messages in [Wasm](https://webassembly.org/) over actor state and uses the
[Wasmtime runtime](https://wasmtime.dev/). This includes a Wasm implementation of the
[EVM bytecode](https://ethereum.github.io/yellowpaper/paper.pdf) interpreter. Under the hood, any
"built-in" and "custom" (subnet-specific) Wasm contracts are compiled to
[CAR](https://docs.ipfs.tech/concepts/how-ipfs-works/#how-ipfs-represents-and-addresses-data) files
and provided to the subnet during genesis.

<Callout>

For further details on how the Wasm runtime works, check out the deep dive
[here](https://docs.filecoin.io/smart-contracts/fundamentals/the-fvm).

</Callout>

Within Recall, our default contracts are called **_Wasm contracts_**. These are the core building
blocks of Recall; each Wasm contract has its own unique address and is associated with a unique
owner address. This helps track which contracts are tied to a given account. At present, Recall
ships with three core Wasm contracts: the _address manager_, _bucket_, and _timehub_. These
contracts are responsible for managing the state of a subnet, creating new buckets, timehubs, and
storing and retrieving data from the subnet.

One of the main advantages of the Wasm runtime is its support for [IPLD](https://ipld.io/), a
hash-linked data model that can be used to represent and traverse hash-linked data. It's the basis
for those familiar with IPFS. All onchain data is represented as IPLD, which is stored in the state
tree of the subnet. Notably, this means you can create Wasm contracts that _use_ IPLD (e.g., Rust's
[libipld](https://github.com/ipld/libipld) crate).

## Wasm vs. smart contracts

Subnets use the Wasm runtime because it offers flexible and data-oriented programmatic control. The
runtime is simply an IPLD-friendly virtual machine that supports Wasm actors and other handy
features.

This flexibility enables the creation of both smart contract and Wasm contracts, the latter of which
allows developers to write programs in languages like Rust, significantly broadening the range of
services and products that can be built. Since the runtime maintains full EVM compatibility,
traditional smart contracts can also be written in Solidity. This dual capability ensures that
developers can leverage the best tools for their specific needs.

## Wasm contracts

Recall comes with a few built-in Wasm contracts that are used to manage the state of the subnet and
implement core data structures.

### Address manager

Clients are able to deploy new buckets on demand using the singleton address manager. The primary
function of the address manager is to create other _Wasm contracts_ and assign them a unique
address. Each Wasm contract is associated with a unique address (which is used to identify the store
on the network), and an owner address.

```mermaid
graph TD
    subgraph Chain["State"]
      subgraph Metadata["Metadata (Hamt)"]
          Root -->|Owner Addr| One["[0x1234]"]
          Root -->|Owner Addr| Two["[0x5678]"]
          Root -->|Owner Addr| Three["[0x4321,\\n0x8765]"]
        end
    end

```

### Buckets

Buckets are deployed as instances of the bucket Wasm contract. This contract is responsible for
managing the state of the bucket itself, including creating, updating, and deleting keys/objects.
Each bucket manages its own metadata state, which is stored on the network and can be accessed by
other contracts. The bucket contract provides a set of methods for interacting with the store,
including `add`, `get`, `query`, and `delete`, which allow clients to store and retrieve data from
the bucket.

These are key-value stores that allow you to push and retrieve data in a familiar S3-like fashion.
Buckets also support byte range requests and advanced queries based on key prefix, delimiter,
offset, and limit.

```mermaid
graph TD
  subgraph State["State"]
    subgraph Chain["Onchain"]
      subgraph Metadata["Metadata (Hamt)"]
          Root -->|Foo Key| FooCid["Foo Cid"]
          Root -->|Bar Key| BarBlock["Bar Blob"]
          Root -->|Baz Key| BazCid["Baz Cid"]
        end
      subgraph Blockstore["Blockstore"]
        FooBlob["Foo Blob"]
      end
      FooCid -->|CID| FooBlob
    end
    subgraph External["Offchain"]
      subgraph Other["Blockstore"]
        BazBlob["Baz Blob"]
      end
    end
    BazCid -->|CID| BazBlob
  end

```

Internally, the state of a bucket is represented as an
[IPLD-based HAMT](https://ipld.io/specs/advanced-data-layouts/hamt/spec/)
([hash array mapped trie](https://en.wikipedia.org/wiki/Hash_array_mapped_trie)). The IPLD data
model provides a flexible and extensible way to represent complex data structures, and the
[invariants and mutation rules](https://michael.steindorfer.name/publications/oopsla15.pdf) enforced
by the IPLD HAMT provides us with the ability to maintain canonical forms given any set of keys and
their values, regardless of insertion order and intermediate data insertion and deletion. Therefore,
for any given set of keys and their values, we get a consistent bucket configuration, such that the
root node will always produce the same CID.

<Callout>

The root commitments (a CID) of the HAMT provide the cryptographic hash required for onchain proof
verification.

</Callout>

The HAMT itself references the blobs of the bucket, which may be included directly (for smaller
payloads that fit entirely within a single transaction), or as part of a _detached payload_. When
required, Recall can leverage the IPLD resolver (and store) to read and write data to its internal
state, so that it is IPLD addressable.
