---
title: Concepts
description: Getting started with basic network concepts.
---

Buckets are buckets that take advantage of Recall's subnet scaling infrastructure to enable fast and
cost-effective storage of large amounts of data. Basin's usage pattern generally consists of two
components:

- Creating an bucket (with certain permissions on who can write data).
- Adding, listing, getting, and deleting objects.

These key-value stores allow you to push and retrieve data in a familiar S3-like fashion. They
support byte range requests and advanced queries based on key prefix, delimiter, offset, and limit.
Internally, the state of an bucket is represented in a flexible and extensible way to represent
complex data structures.

## Contracts

The interface is implemented as a _contract_, deployed on a subnet. Data is represented as an
onchain hash within a contract's state, and the actual data is stored offchain in a node's local
(networked) block store. Spawning new buckets is handled with a general factory smart contract,
which the various Basin interfaces (SDK, CLI) call under the hood.

More generally, there are two types of contracts on Recall network: **_Wasm_** contracts, and EVM
**_smart_** contracts. The two differ in how what they can handle and related intents.

### Wasm contract

A _Wasm_ contract is an
[Wasm runtime contract](https://docs.filecoin.io/basics/the-blockchain/actors) used to store and
manage data with low-level control. The polyglot execution runtime allows Wasm contracts to be
written in Rust (or other languages) and then compiled accordingly. Thus, these have more flexible
and data-oriented programmatic control, so they're called "Wasm contracts" to help distinguish them
from EVM smart contracts.

### Smart contract

A _smart_ contract is a "traditional" EVM contract, most commonly written in Solidity. These expose
EVM-specific types, state access, and functionality, but they lack the more robust features that a
Wasm runtime supports.

## Accounts

Accounts (ECDSA, secp256k1) are used to send data-carrying transactions as you would on any
blockchain system. Thus, all mutations are onchain transactions within a subnet, so funds are
required to pay for writes. Since Basin is built on top of Filecoin's FVM, the addresses can follow
a _slightly_ different convention than a purely EVM-based account system.

### EVM addresses

You can use EVM-style (i.e., `0x` prefixed) accounts for typical wallet operations (writes, sending
transactions, etc.). Wasm contracts, such as buckets, are represented as hex addresses as well.

### Wasm addresses

All Wasm contract addresses are represented a bit differently than your typical EVM wallet or
contract contract. Its usage pattern doesn't change; the format just looks _slightly_ unusual.

Every Wasm contract has an unique internal chain identifier associated with it called an _actor ID_.
You'll see Wasm contracts are predictably represented as `0xff00...<actor_id>`. For example, a
bucket with an ID of `143` would be `0xff0000000000000000000000000000000000008f` (since the hex
value of `143` is `8f`).

## Payment

### Tokens

Tokens are used to pay for typical blockchain operations, like deploying contracts (e.g., creating a
bucket), adding an object, or transferring funds. Whenever _data is written_ to a contract and
stored as a blob on the network, _credits_ are used.

<Callout>

You'll often see the phrase _native coin_ or _native token_. A Recall subnet doesn't really "care"
what the native coin is; it simply uses the concept of a token as a medium of exchange for chain
transactions. In practice, the parent rootnet specifies a _supply source_ upon subnet creation,
dictating how you move funds into or out of the subnet through deposits and withdrawals. This is
where the RECALL ERC20 token is used; it's the supply source on the parent chain defined for the
child subnet.

</Callout>

### Credits

Credits are a useful mechanism to predictably manage storage costs and avoid surprises, and they are
used to pay for all storage within the Recall network. You can sponsor (delegate) your credits to
contracts on the network, and whenever data is written to a contract, credits are debited from your
credit balance upon ongoing debit epochs (sparse block heights). It allows for more fine-grained
accounting because 1 subnet native coin = $10^(18)$ credits.

Namely, you **MUST have credits** to store data on Recall. For example, to add an object to a
bucket, you spend credits that allocate storage space for the object, including
[TTL](#time-to-live-ttl) parameters. Credits will automatically get withdrawn from your credit
balance as storage continues.

You can manage your credits with the `recall credit` command, further described in the
[credits](/basin/cli/commands#credits) section below.

### Gas allowance

Whenever you purchase credits, the number of tokens you spend will also be allocated to a _gas
allowance_ for your account. Recall that tokens are used to pay for gas. If you have a gas allowance
balance, you'll instead draw down from this balance. For example, if you create a bucket _and_ you
have a gas allowance, your token balance will remain unchanged, but your gas allowance will
decrease. In the same example but with _no gas allowance balance_, you'll simply draw down from your
token balance.

## Access control

Access control is fully managed by credit workflows with approvals and revocations. You start buy
purchasing credit with an account (i.e., wallet), and once this account creates a bucket, all object
related storage operations will draw down from these credits.

If you want to enable other accounts to write to this bucket, you can use a credit _approval_ to
enable some other account to draw down from this admin account's credit balance. Revocations follow
the same pattern where you can revoke an approval for a provisioned account.

## Broadcasting transactions

Commands that write data will broadcast a transaction to the network. You'll see a
`--broadcast-mode` flag that can be set to the following values:

- `commit`: Wait until the transaction is delivered and final (note: this is the default behavior).
- `sync`: Wait only for the result of a local transaction pre-check, but don’t wait for it to be
  delivered to all validators (i.e., added risk the transaction may fail during delivery).
- `async`: Does not wait at all. You will not see errors in your terminal (i.e., added risk the
  transaction may fail during delivery).

## Querying state

Many of the read-only commands let you pass a `--height` option to query the chain's state at a
specific block height. The following describes the three possible values you can use:

- `committed`: The latest committed block (note: this is the default behavior).
- `pending`: Consider pending state changes in the query.
- `<number>`: Pass a specific block height (e.g., `123`) to fetch state from.

## Time-to-live (TTL)

A few operations—like uploading objects to buckets—have a time-to-live (TTL) value (denoted by the
`--ttl` flag). It's primarily used for objects stored in buckets.

The TTL value you set represents how long the object will be stored in the network before it is
garbage collected and deleted. If a TTL is specified, credits will be reserved for the duration,
after which the object will be deleted. If a TTL is not specified, the object will be continuously
renewed about every hour. If the owner's free credit balance is exhausted, the object will be
deleted.

## Chain RPCs & funds

First, to get RECALL tokens, reach out to the Recall team.

Since Basin is built on top of Filecoin, you must also have FIL in your account to interact with the
network if you are bridging RECALL tokens into the subnet. Recall is currently only live on the
Filecoin Calibration network. You can get tFIL via the faucet
[here](https://faucet.calibnet.chainsafe-fil.io/funds.html), and for reference, Filecoin chain
information can be found [here](https://chainlist.org/?search=filecoin&testnets=true).
