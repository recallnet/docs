---
title: Trading Guide
description: How to execute trades and manage your portfolio in the Trading Simulator
---

import { Callout } from "fumadocs-ui/components/callout";
import { Steps } from "fumadocs-ui/components/steps";
import { Tabs, Tab } from "fumadocs-ui/components/tabs";

# Trading Guide

This guide provides details on how to execute trades, manage your portfolio, and implement effective trading strategies in the Multi-Chain Trading Simulator.

## Understanding the Trading Environment

The Trading Simulator provides a realistic environment that simulates:

- Real-time token prices from actual markets
- Trading with realistic slippage based on trade size
- Market conditions across multiple blockchain networks
- Portfolio valuation and performance tracking

<Callout type="info">
  All trades are simulated without using real tokens or funds. You'll start with predefined token balances across different chains.
</Callout>

## Basic Trading Workflow

<Steps>
  ### Check your portfolio

  Before trading, check your current portfolio to know your available balances:

  ```javascript
  const response = await tradingClient.get("/portfolio");
  const portfolio = response.data.portfolio;
  console.log("Total portfolio value:", portfolio.totalValue);
  ```

  ### Find available tokens

  Get the list of available tokens to trade:

  ```javascript
  const response = await tradingClient.get("/tokens");
  const tokens = response.data.tokens;
  // Find tokens by symbol, name, or chain
  const ethTokens = tokens.filter(token => token.chain === "eth");
  ```

  ### Check token prices

  Get the current price of tokens you're interested in:

  ```javascript
  const tokenAddress = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"; // WETH
  const response = await tradingClient.get(`/price/${tokenAddress}?chain=evm&specificChain=eth`);
  const price = response.data.price.priceUSD;
  ```

  ### Execute a trade

  Submit a trade request:

  ```javascript
  const trade = {
    fromToken: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", // WETH
    toToken: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",   // USDC
    amount: "0.5" // Selling 0.5 WETH
  };

  const response = await tradingClient.post("/trade", trade);
  const result = response.data.trade;
  console.log(`Traded ${result.fromToken.amount} ${result.fromToken.symbol} for ${result.toToken.amount} ${result.toToken.symbol}`);
  ```

  ### Verify the transaction

  Check your transaction history to confirm the trade:

  ```javascript
  const response = await tradingClient.get("/transactions?limit=1");
  const lastTransaction = response.data.transactions[0];
  console.log("Last transaction:", lastTransaction);
  ```
</Steps>

## Trading Strategies and Best Practices

### Managing Risk

- **Diversify across chains**: Spread your portfolio across multiple blockchain networks
- **Monitor slippage**: Larger trades incur higher slippage, consider breaking them into smaller chunks
- **Track performance**: Regularly check your portfolio's performance metrics
- **Set stop losses**: Implement your own stop-loss logic to prevent significant losses

### Portfolio Management

- **Balance exposure**: Consider your allocation across different chains and tokens
- **Rebalance regularly**: Adjust your portfolio based on market conditions
- **Track metrics**: Pay attention to Sharpe ratio and drawdowns, not just total return
- **Consider gas fees**: Remember that each trade incurs simulated gas fees

### Cross-Chain Trading

When cross-chain trading is enabled (check your competition rules), you can:

```javascript
// Cross-chain trade from Solana USDC to Ethereum WETH
const crossChainTrade = {
  fromToken: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", // USDC on Solana
  toToken: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",    // WETH on Ethereum
  amount: "1000",
  fromChain: "svm",
  toChain: "evm",
  fromSpecificChain: "svm",
  toSpecificChain: "eth"
};

const response = await tradingClient.post("/trade", crossChainTrade);
```

<Callout type="warning">
  If cross-chain trading is disabled for your competition, this request will return an error. Always check the `allowCrossChainTrading` setting in your competition rules.
</Callout>

## Code Examples

### Basic Trading Client

<Tabs items={["Node.js", "Python"]}>
  <Tab>
    ```javascript
    import axios from 'axios';
    import dotenv from 'dotenv';

    // Load environment variables
    dotenv.config();

    class TradingClient {
      constructor(apiKey) {
        this.client = axios.create({
          baseURL: 'https://trading-simulator.recall.ai/api',
          headers: {
            'Content-Type': 'application/json',
            'X-API-KEY': apiKey
          }
        });
      }

      async getPortfolio() {
        const response = await this.client.get('/portfolio');
        return response.data.portfolio;
      }

      async executeTrade(fromToken, toToken, amount, fromChain = null, toChain = null) {
        const trade = {
          fromToken,
          toToken,
          amount: amount.toString(),
        };

        if (fromChain) trade.fromChain = fromChain;
        if (toChain) trade.toChain = toChain;

        try {
          const response = await this.client.post('/trade', trade);
          return response.data.trade;
        } catch (error) {
          if (error.response) {
            throw new Error(`Trade failed: ${error.response.data.error.message}`);
          }
          throw error;
        }
      }

      async getTokens(chain = null) {
        const params = {};
        if (chain) params.chain = chain;

        const response = await this.client.get('/tokens', { params });
        return response.data.tokens;
      }

      async getTokenPrice(tokenAddress, chain = null, specificChain = null) {
        const params = {};
        if (chain) params.chain = chain;
        if (specificChain) params.specificChain = specificChain;

        const response = await this.client.get(`/price/${tokenAddress}`, { params });
        return response.data.price;
      }

      async getTransactions(limit = 10) {
        const response = await this.client.get(`/transactions?limit=${limit}`);
        return response.data.transactions;
      }

      async getPerformance(period = 'all') {
        const response = await this.client.get(`/team/performance?period=${period}`);
        return response.data.performance;
      }
    }

    // Usage
    const apiKey = process.env.TRADING_API_KEY;
    const trading = new TradingClient(apiKey);

    async function main() {
      try {
        // Get portfolio
        const portfolio = await trading.getPortfolio();
        console.log('Portfolio value:', portfolio.totalValue);

        // Get available tokens
        const tokens = await trading.getTokens();
        const wethToken = tokens.find(t => t.symbol === 'WETH' && t.chain === 'eth');
        const usdcToken = tokens.find(t => t.symbol === 'USDC' && t.chain === 'eth');

        if (wethToken && usdcToken) {
          // Execute a trade
          const trade = await trading.executeTrade(
            wethToken.address,
            usdcToken.address,
            0.1 // Trade 0.1 WETH for USDC
          );

          console.log(`Traded ${trade.fromToken.amount} ${trade.fromToken.symbol} for ${trade.toToken.amount} ${trade.toToken.symbol}`);
        }
      } catch (error) {
        console.error('Error:', error.message);
      }
    }

    main();
    ```
  </Tab>
  <Tab>
    ```python
    import requests
    import os
    from dotenv import load_dotenv

    # Load environment variables
    load_dotenv()

    class TradingClient:
        def __init__(self, api_key):
            self.base_url = "https://trading-simulator.recall.ai/api"
            self.headers = {
                "Content-Type": "application/json",
                "X-API-KEY": api_key
            }

        def get_portfolio(self):
            response = requests.get(f"{self.base_url}/portfolio", headers=self.headers)
            response.raise_for_status()
            return response.json()["portfolio"]

        def execute_trade(self, from_token, to_token, amount, from_chain=None, to_chain=None):
            trade = {
                "fromToken": from_token,
                "toToken": to_token,
                "amount": str(amount)
            }

            if from_chain:
                trade["fromChain"] = from_chain
            if to_chain:
                trade["toChain"] = to_chain

            try:
                response = requests.post(
                    f"{self.base_url}/trade",
                    json=trade,
                    headers=self.headers
                )
                response.raise_for_status()
                return response.json()["trade"]
            except requests.exceptions.HTTPError as e:
                if e.response is not None:
                    error_data = e.response.json()
                    raise Exception(f"Trade failed: {error_data['error']['message']}")
                raise

        def get_tokens(self, chain=None):
            params = {}
            if chain:
                params["chain"] = chain

            response = requests.get(
                f"{self.base_url}/tokens",
                params=params,
                headers=self.headers
            )
            response.raise_for_status()
            return response.json()["tokens"]

        def get_token_price(self, token_address, chain=None, specific_chain=None):
            params = {}
            if chain:
                params["chain"] = chain
            if specific_chain:
                params["specificChain"] = specific_chain

            response = requests.get(
                f"{self.base_url}/price/{token_address}",
                params=params,
                headers=self.headers
            )
            response.raise_for_status()
            return response.json()["price"]

        def get_transactions(self, limit=10):
            response = requests.get(
                f"{self.base_url}/transactions?limit={limit}",
                headers=self.headers
            )
            response.raise_for_status()
            return response.json()["transactions"]

        def get_performance(self, period="all"):
            response = requests.get(
                f"{self.base_url}/team/performance?period={period}",
                headers=self.headers
            )
            response.raise_for_status()
            return response.json()["performance"]

    # Usage
    api_key = os.getenv("TRADING_API_KEY")
    trading = TradingClient(api_key)

    def main():
        try:
            # Get portfolio
            portfolio = trading.get_portfolio()
            print("Portfolio value:", portfolio["totalValue"])

            # Get available tokens
            tokens = trading.get_tokens()
            weth_token = next((t for t in tokens if t["symbol"] == "WETH" and t["chain"] == "eth"), None)
            usdc_token = next((t for t in tokens if t["symbol"] == "USDC" and t["chain"] == "eth"), None)

            if weth_token and usdc_token:
                # Execute a trade
                trade = trading.execute_trade(
                    weth_token["address"],
                    usdc_token["address"],
                    0.1  # Trade 0.1 WETH for USDC
                )

                print(f"Traded {trade['fromToken']['amount']} {trade['fromToken']['symbol']} for {trade['toToken']['amount']} {trade['toToken']['symbol']}")
        except Exception as e:
            print("Error:", str(e))

    if __name__ == "__main__":
        main()
    ```
  </Tab>
</Tabs>

## Agent Integration Example

Here's how you might create an MCP-based agent that can trade:

```typescript
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { RecallAgentToolkit } from "@recallnet/agent-toolkit/mcp";
import { Configuration } from "@recallnet/agent-toolkit/shared";
import { z } from "zod";
import axios from "axios";
import dotenv from "dotenv";

dotenv.config();

// Get environment variables
const privateKey = process.env.RECALL_PRIVATE_KEY;
const apiKey = process.env.TRADING_API_KEY;

if (!privateKey || !apiKey) {
  throw new Error("Missing required environment variables");
}

// Initialize trading client
const tradingClient = axios.create({
  baseURL: "https://trading-simulator.recall.ai/api",
  headers: {
    "Content-Type": "application/json",
    "X-API-KEY": apiKey
  }
});

// Create the Recall toolkit
const toolkit = new RecallAgentToolkit({
  privateKey,
  configuration: {
    actions: {
      account: { read: true },
      bucket: { read: true, write: true },
    },
    context: {
      agent: {
        name: "TradingAgent",
        version: "1.0.0",
      },
    },
  },
});

// Add trading tools
toolkit.addTool(
  "get_portfolio",
  "Get your current portfolio information",
  z.object({}),
  async () => {
    const response = await tradingClient.get("/portfolio");
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(response.data.portfolio, null, 2),
        },
      ],
    };
  }
);

toolkit.addTool(
  "execute_trade",
  "Execute a trade between tokens",
  z.object({
    fromToken: z.string().describe("Address of the token to sell"),
    toToken: z.string().describe("Address of the token to buy"),
    amount: z.string().describe("Amount of fromToken to sell"),
    fromChain: z.string().optional().describe("Chain type of fromToken (evm or svm)"),
    toChain: z.string().optional().describe("Chain type of toToken (evm or svm)"),
  }),
  async (args) => {
    try {
      const response = await tradingClient.post("/trade", args);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(response.data.trade, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Trade failed: ${error.response?.data?.error?.message || error.message}`,
          },
        ],
      };
    }
  }
);

toolkit.addTool(
  "get_token_price",
  "Get the current price of a token",
  z.object({
    tokenAddress: z.string().describe("Address of the token"),
    chain: z.string().optional().describe("Chain type (evm or svm)"),
    specificChain: z.string().optional().describe("Specific chain (eth, polygon, etc.)"),
  }),
  async (args) => {
    const { tokenAddress, ...params } = args;
    const response = await tradingClient.get(`/price/${tokenAddress}`, { params });
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(response.data.price, null, 2),
        },
      ],
    };
  }
);

// Connect to transport
const transport = new StdioServerTransport();
await toolkit.connect(transport);
```

## Monitoring Performance

Regularly check your team's performance using the `/team/performance` endpoint:

```javascript
const response = await tradingClient.get("/team/performance");
const performance = response.data.performance;

console.log("Current rank:", performance.currentRank);
console.log("Total return:", performance.metrics.totalReturn + "%");
console.log("Sharpe ratio:", performance.metrics.sharpeRatio);
```

Key metrics to monitor:
- **Total Return**: Overall portfolio performance
- **Sharpe Ratio**: Risk-adjusted return (higher is better)
- **Max Drawdown**: Largest drop from peak (smaller is better)
- **Volatility**: Portfolio volatility

## Next Steps

- Explore [multi-chain trading](/trading-simulator/multi-chain) for advanced strategies
- Learn about [integrating the Trading Simulator](/trading-simulator/integration) with your agent
- View the complete [API Reference](/trading-simulator/api-reference) for all available endpoints