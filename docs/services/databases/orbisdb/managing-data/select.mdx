---
title: Querying data
description: Learn how to query data in OrbisDB.
---

OrbisDB aims to provide a universal experience when building with decentralized data. We made sure
to build multiple ways for users to explore their data.

## Flow of data

Unlike writes and updates, querying data from OrbisDB does not rely on Ceramic. Once data gets
indexed, it is served directly from your OrbisDB instance. Your application and users will interface
with OrbisDB directly to query data and get the results they need. This can be done using our
[Data dashboard](/databases/orbisdb-dashboard-reference), SDK with an ORM-like interface or GraphQL.

## `SELECT` in OrbisDB

OrbisDB indexing is backend by PostgreSQL. This allows users maximum flexibility when managing and
querying their data.

### Data dashboard

> Data dashboard SQL queries use a private API with both read and write permissions.

Data stored in the OrbisDB can be viewed through our Data dashboard. This is usually the first point
of contact with your decentralized data as it's simple to use and ready-to-go.

You can start exploring your OrbisDB data by visiting the `Data` section of your OrbisDB Dashboard.
Here you'll see all the tables (Models) that are currently being indexed. You can browse them
directly or use our `Editor` to write custom SQL or GraphQL queries.

Check out more in our [Dashboard reference](/databases/orbisdb-dashboard-reference).

### ORM-like SDK

> Queries ran using the SDK go through the public API interface and are ran using a read-only
> PostgreSQL user. This prevents any malicious query attempts at the DB level.

While not an ORM, OrbisDB SDK comes with a simple query builder. This allows you to programmatically
build SQL queries without having to know any SQL in the first place. Queries get serialized as JSON
and sent over a public REST API.

Check out our [SDK reference](/databases/orbisdb-sdk-reference/select) to explore more advanced
queries, operators and more.

#### Query builder `SELECT`

The below code sample will select all rows that match `columnName = 'value'`, returning all columns.

```jsx
const { columns, rows } = await orbis
  .select()
  .from("MODEL_ID" | "MODEL_ALIAS" | "VIEW")
  .where({
    column_name: "value",
  })
  .context("CONTEXT_ID")
  .run();

// SELECT * FROM table WHERE column_name = 'value';
console.log("Retrieved data", rows);
```

### Raw SQL

> Queries ran using the SDK go through the public API interface and are ran using a read-only
> PostgreSQL user. This prevents any malicious query attempts at the DB level.

If you don't wish to use a query builder and prefer abstraction-less code, you can use the SDK to
write SQL queries directly, the same way you would if you were using a centralized database and a
package such as `node-pg`.

The communication happens over the same REST endpoint and return values remain the same.

#### Raw `SELECT` statement

```jsx
// When using the .raw() no other helper methods can be used
const { columns, rows } = await orbis
  .select()
  .raw("SELECT * FROM table WHERE column_name = $1", ["value"])
  .run();

// SELECT * FROM table WHERE column_name = 'value';
console.log("Retrieved data", rows);
```

### GraphQL **`BETA`**

> Queries ran using GraphQL go through the public API interface and are ran using a read-only
> PostgreSQL user. This prevents any malicious query attempts at the DB level.

All OrbisDB instances include a public GraphQL endpoint. This can be used in combination with
existing GraphQL clients to enable a familiar developer experience.

#### GraphQL `SELECT` query

```jsx
// In SQL terms this would be equal to
// SELECT columnName, anotherColumn FROM table WHERE columnName = 'value';
{
	table(filter:{ column_name: "value" }) {
		column_name,
		another_column
	}
}
```

## Advanced queries

SQL has been around for decades and it's grown into an extremely robust way of querying data.
Relational data model are coupled with concepts such as joins, foreign keys and others.

We will only briefly touch on some in this section, but you can check out
[Advanced queries](/databases/orbisdb-managing-data/advanced) for more information.

### Joins

Joins enable you to, well, _join_ data across multiple tables (Models). This is the core concept of
relational data, as data across tables often relates to each other in one way or another. They
aren't (yet) built into our SDK query builder, but they are available via raw SQL queries and
GraphQL.

You can read more about Joins in our [Advanced queries](/databases/orbisdb-managing-data/advanced)
section.

### Views

Views allow you to name commonly used queries (including joins, filters, etc). You can use them as
any other table and you can access them through all the OrbisDB query methods.

Learn how to create Views in our [Advanced queries](/databases/orbisdb-managing-data/advanced)
section.

### Indexes

When accessing data, the database engine (PostgreSQL) needs to go through _all_ the rows in your
table before finding the result. This isn't efficient, especially as your datasets grow. Indexes
create a "cache" of sorts that can be used to quickly determine which rows match your query, without
having to go through all the entries.

OrbisDB creates some indexes automatically, you can find out more in our
[Advanced queries](/databases/orbisdb-managing-data/advanced) section.

## Summary

When querying data, you and your users are interfacing with OrbisDB directly. Owners can do this
using our built-in [Data dashboard](/databases/orbisdb-dashboard-reference), or use an SDK paired
with ORM-like and GraphQL interfaces.

The flow is as follows

1. User interacts with the OrbisDB directly
   1. Data dashboard
   2. ORM-like SDK (query builder)
   3. Raw SQL
   4. GraphQL
2. OrbisDB handles permissions and locates the data
3. Data gets loaded from the database and returned to the user
