---
title: Decentralized web forum
description: Build a user-owned web forum using OrbisDB.
---

## Overview

Creating and maintaining a successful social web forum presents unique challenges and opportunities.
As platforms strive to foster meaningful discussions and user engagement, the ability to efficiently
manage user-generated content, track interactions, and ensure platform integrity becomes paramount.
Moreover, the traditional landscape of online communities has historically been built on
infrastructure that does not allow end users to "own" the content they create, resulting in platform
lock-in and non-transferable user identity and reputation.

So, what do users and developers stand to gain from infrastructure that allows for user-owned data?
If end users can seamlessly create cross-platform reputation datasets using features like the
ability to grant, revoke, and monetize the accessibility of their data, this unlocks entirely novel
ways of architecting and enjoying applications. Teams building on said infrastructure can circumvent
the cold-start problem by accessing user data on day one, while the data lives on independently
under the control of the users who author it and have the agency to decide how their data is used,
and what the value of that data is.

Given these potential benefits, tools that offer clear ownership properties and data lineage
features can significantly benefit social web forum architects. This is where Recall's Event Storage
capabilities come into play.

## Recall Event Storage for Social Web Forums

At the core of Recall's Event Storage lies an innovative decentralized data architecture called
Ceramic that enables the creation of verifiable, traceable event streams. This network technology
forms the foundation for building sophisticated relational databases, secure private storage
systems, and responsive event-driven applications. One of Ceramic’s hallmark features is its ability
to ensure data integrity and maintain a clear lineage of information ownership and origination,
which is particularly valuable for building decentralized social web forums.

Let's explore how this technology can be applied to enhance forum functionality:

- **User-Centric Data Ownership**: All forum content, including posts, comments, and user
  interactions, is associated with a unique decentralized identifier. This identifier can be linked
  to various authentication methods, including blockchain wallets or cryptographic key pairs,
  ensuring users retain control over their contributions. This feature is essential to prove
  origination if leveraging these datasets across platforms.
- **Immutable Content History**: The network creates "streams" for each content piece, formatted in
  cryptographically signed, self-certifying event logs. Streams can only be modified by the original
  creator or authorized entities, maintaining a clear chain of custody for all forum content.
- **Transparent Revision Tracking**: Each update or edit to forum content is recorded in its
  respective stream, creating a transparent and auditable history of changes. This feature is
  invaluable for moderation purposes and maintaining the integrity of discussions.
- **Interoperability and Privacy Features**: The decentralized nature of the data structure,
  synchronization capabilities, and the ability for users to create private datasets opens up
  possibilities for innovative forum features. For instance, it becomes feasible to implement
  federated forums where discussions can seamlessly span across multiple platforms while preserving
  data ownership and provenance.

Given these powerful capabilities, this technical guide will demonstrate how to harness Recall Event
Storage to construct a social web forum. We aim to showcase how Recall Event Storage can be
leveraged to create a platform that sets new standards in transparency, moderation efficiency, and
data integrity in online communities.

## Social Web Forum Overview

As mentioned above, we will set up a web forum that uses one of Recall’s Event Storage
configurations to store user data. Once setup is complete, you’ll have something up and running that
looks similar to this:

![deforum screenshot](/img/tutorials/deforum/deforum-screenshot.png)

### Key Components and Features

To bring this use case full circle, this demo implements several key capabilities:

- User profiles
  - An edit page
  - A public page (displays profile information and posts created by that user)
- Posts
  - A create page
  - Dynamic post pages (displays the original post and corresponding comments)
- Comments
  - Ability to create a comment when visiting a post’s page

This design will require defining relations between models and query patterns to join and format
tables to accommodate our UI. This will allow us to explore the implementation of this pattern using
Recall Event Storage.

### Key Dependencies

This demo relies on the following frameworks and providers to support and facilitate a web forum
design:

**OrbisDB**

The previous section mentioned that databases can be built on Ceramic’s event streams.
[OrbisDB](https://useorbis.com/) is one of those implementations, offering a relational database
interface, and features like plugins, a developer UI, and even a shared hosted instance for
experimentation.

User data like posts, comments related to posts, and user profiles are highly relational. We will
therefore use OrbisDB (and its SDK) to allow our users to create their forum data.

**IPFS**

Recall’s Event Storage solution, Ceramic, is designed to support text-based data. Recall’s data
availability layer is built to store arbitrary data, making Basin is a good fit for this. However,
for this tutorial we will rely on IPFS to allow our users to store rich media assets like images for
user profiles or in the body of posts and comments. For this, we will use the
[ThirdWeb SDK](https://thirdweb.com/) which will give us access to an IPFS storage solution.

**WalletConnect**

Finally, this demo will require a project ID from [WalletConnect](https://cloud.walletconnect.com/)
to allow users to self-authenticate using a wallet provider.

## Getting Started

First, create a local clone of the application:

```bash
git clone https://github.com/ceramicstudio/deforum && cd deforum
```

Next, install your dependencies:

```bash
pnpm install
```

### Environment Setup

You will need to create a copy of the example environment file:

```bash
cp .env.example .env.local
```

First, create a value for `AUTH_SECRET` (will be required if you ever decide to re-integrate some of
the other services that rely on NextAuth):

```bash
openssl rand -base64 32
```

**ThirdWeb**

Next, you will need a value for your `NEXT_PUBLIC_THIRDWEB_ID`. Log into
your [ThirdWeb Dashboard](https://thirdweb.com/dashboard) and go to the "Settings" tab on the upper
left-hand side. Create a new API key with "Storage" as an enabled service with read + write access.
Once done, copy the "Client ID" and assign it to your env value.

![thirdweb dashboard](/img/tutorials/deforum/thirdweb-dashboard.png)

**WalletConnect**

Obtain a Client ID from WalletConnect as the demo uses it for its wallet provider. Log into
your [WalletConnect Cloud Dashboard](https://cloud.walletconnect.com/) and create a new project
(with the "App" type selected). Once created, copy the "Project ID" and assign it
to `NEXT_PUBLIC_PROJECT_ID`.

**OrbisDB**

The next few values will be associated with OrbisDB. We will use the
hosted [OrbisDB Studio](https://studio.useorbis.com/) and the shared node instance it provides to
keep things simple for this demo but keep in mind that you can set up a separate instance whenever
you want (more details at [OrbisDB](https://useorbis.com/)).

First, go ahead and sign in with your wallet.

Once signed in, the studio will default to the "Contexts" tab at the top. On the right-hand side,
you will see your environment ID. Go ahead and assign that value to `ENV_ID` in your new .env file.

![orbisdb context](/img/tutorials/deforum/orbisdb-contexts.png)

Next, set up a context. These help developers segment their data models and usage based on the
applications they are meant for. Create a new context (you can call it "forum" if you'd like), and
assign the resulting string to CONTEXT_ID in your .env file.

![orbisdb copy context](/img/tutorials/deforum/orbisdb-copy-context.png)

Finally, you will create three tables using the OrbisDB model builder feature that this application
will leverage for user data.

In your Orbis Studio view, select the "Model Builder" tab at the top and create a new model named
"profile" using the profile definition (also found
in [this document](https://github.com/ceramicstudio/deforum/blob/main/models/tables.sql)).

```sql
-- SINGLE accountRelation
table profile {
  name string
  username string
  profile_imageid string
  description string
}

-- LIST accountRelation
table comment {
  comment string
  created DateTime
  imageid string
  poststream string
}

-- LIST accountRelation
table post {
  title string
  body string
  created DateTime
  imageid string
}
```

![orbisdb model creation](/img/tutorials/deforum/orbisdb-model-creation.png)

Once created, assign the resulting identifier to `NEXT_PUBLIC_PROFILE_ID`.

Do the same for comment --> `NEXT_PUBLIC_COMMENT_ID` and post --> `NEXT_PUBLIC_POST_ID`.

## Architecture Overview

Several key pieces of our application are responsible for authenticating users, accessing OrbisDB,
and writing to our data store. Let’s take a look at a few of them:

**Authentication**

If you check out the base
[layout](https://github.com/ceramicstudio/deforum/blob/main/app/layout.tsx) file, you can see where
the `<WalletProvider>` is imported (from WalletConnect). You’ll also see `<ODB>` (our OrbisDB
contextual wrapper).

If you navigate to the
[OrbisContext](https://github.com/ceramicstudio/deforum/blob/main/app/context/OrbisContext.tsx) file
which houses the wrapper’s logic, you’ll notice how the OrbisDB SDK is being used to instantiate an
Orbis client (which will be used in separate components for reading and writing data), as well as
authenticating users:

```tsx
import { type OrbisConnectResult, OrbisDB, type SiwxAttestation } from "@useorbis/db-sdk";
import { OrbisEVMAuth } from "@useorbis/db-sdk/auth";

// instantiating an OrbisDB client instance (using your ENV_ID)
const orbis = new OrbisDB({
  ceramic: {
    gateway: "https://ceramic-orbisdb-mainnet-direct.hirenodes.io/",
  },
  nodes: [
    {
      gateway: "https://studio.useorbis.com",
      env: ENV_ID,
    },
  ],
});

// authenticating users
const StartOrbisAuth = async (): Promise<OrbisConnectResult | undefined> => {
  const auth = new OrbisEVMAuth(window.ethereum!);
  // Authenticate - this option persists the session in local storage
  const authResult: OrbisConnectResult = await orbis.connectUser({
    auth,
  });
  if (authResult.session) {
    return authResult;
  }

  return undefined;
};
```

There are also several spots in this component where `loaded` events are emitted. The UI will listen
for these events, query user data, and paint the UI in response.

**Reading Data**

While the OrbisDB SDK allows data to be queried via GraphQL, this demo will only use SQL. Developers
can leverage the built-in SDK’s ORM or raw SQL to read data. Queries must reference the table being
read or written to (as well as the context), which is why corresponding components import the client
environment variables you created in the previous section.

Take a look at how the ORM is used in
[profile-modules](https://github.com/ceramicstudio/deforum/blob/main/components/sections/profile-modules.tsx),
for example:

```tsx
import { useODB } from "@/app/context/OrbisContext";

/*....*/

// using the contextual hook to access our authenticated OrbisDB client
const { orbis } = useODB();

const PROFILE_ID = env.NEXT_PUBLIC_PROFILE_ID ?? "";
const CONTEXT_ID = env.NEXT_PUBLIC_CONTEXT_ID ?? "";

/*....*/

const getProfile = async (): Promise<void> => {
  try {
    // making sure our authenticated instance is ready
    const user = await orbis.getConnectedUser();
    if (user) {
      const profile = orbis
        // selecting the columns we want corresponding data from
        .select("name", "username", "profile_imageid", "description")
        // indicating which table we want to read from
        .from(PROFILE_ID)
        // filtering based on the current authenticated account
        .where({ controller: user.user.did.toLowerCase() })
        // using our context
        .context(CONTEXT_ID);
      const profileResult = await profile.run();
      console.log(profileResult);
      if (profileResult.rows.length) {
        setProfile(profileResult.rows[0] as Profile);
      }
    }
  } catch (error) {
    console.error(error);
    return undefined;
  }
};
```

Conversely, there are several components where we need to leverage more complex queries. For
example, our dynamic
[posts component](<https://github.com/ceramicstudio/deforum/blob/main/app/(home)/(posts)/post/%5Bslug%5D/page.tsx>)
renders all corresponding comments (and the authors of those comments) for any given post page. In
cases like these we can use the raw SQL feature:

```tsx
// input is the stream ID of the post
const getPost = async (stream_id: string): Promise<void> => {
  try {
    setPostStream(stream_id);
    const user = await orbis.getConnectedUser();
    if (user) {
      const query = await orbis
        .select()
        .raw(
          `
          SELECT
					    *,
					    (
					        SELECT json_build_object(
					            'name', name,
					            'username', username,
					            'description', description,
					            'profile_imageid', profile_imageid,
					            'stream_id', stream_id
					     )
			        FROM ${env.NEXT_PUBLIC_PROFILE_ID} AS profile
			        WHERE profile.controller = post.controller
							 ) AS profile,
				       (
					        SELECT json_agg(
					            json_build_object(
					                'comment', comment,
					                'imageid', imageid,
					                'profile', (
					                    SELECT json_build_object(
					                        'name', name,
					                        'username', username,
					                        'description', description,
					                        'profile_imageid', profile_imageid,
					                        'stream_id', stream_id
					                    )
					                    FROM ${env.NEXT_PUBLIC_PROFILE_ID} AS profile
					                    WHERE profile.controller = comment.controller
					                )
					            )
					        )
					        FROM ${env.NEXT_PUBLIC_COMMENT_ID} AS comment
					        WHERE comment.poststream = post.stream_id
						    ) AS comments
						FROM ${env.NEXT_PUBLIC_POST_ID} AS post
						WHERE post.stream_id = '${stream_id}'
          `
        )
        .run();
      const postResult = query.rows as Post[];
      if (postResult.length) {
        setMessage(postResult[0]);
      }
    }
  } catch (error) {
    console.error(error);
    return undefined;
  }
};
```

**Writing Data**

Creating records will exclusively make use of the SDK’s ORM. These queries will have a similar feel
to reads. For example, when creating a post in the
[newPost-modules](https://github.com/ceramicstudio/deforum/blob/main/components/sections/newPost-modules.tsx)
file:

```tsx
// uses the ThirdWeb SDK for uploading files
const uploadToIpfs = async () => {
  const uploadUrl = await upload({
    data: [file],
    options: { uploadWithGatewayUrl: true, uploadWithoutDirectory: true },
  });
  return uploadUrl[0];
};

const createPost = async (): Promise<void> => {
  try {
    if (!title || !body) {
      alert("Please fill in the title and body of the post.");
      return;
    }
    const user = await orbis.getConnectedUser();
    if (user) {
      // posts can optionally contain an image
      let imageUrl;
      if (file) {
        imageUrl = await uploadToIpfs();
      }

      const created = new Date().toISOString();
      const createQuery = await orbis
        .insert(POST_ID)
        .value({
          title,
          body,
          imageid: imageUrl ? imageUrl : "",
          created,
        })
        .context(CONTEXT_ID)
        .run();

      if (createQuery.content) {
        setPost({
          title,
          body,
          imageid: imageUrl ? imageUrl : "",
          stream_id: createQuery.content.stream_id,
          profile,
          created,
        });
      }
    }
  } catch (error) {
    console.error(error);
    return undefined;
  }
};
```

## Running the Application

You are now ready to run the application! In your terminal, use the following command to start the
demo in developer mode:

```bash
pnpm dev
```

Navigate to [`http://localhost:3000/`](http://localhost:3000/) in your browser. You should see the
following (light mode toggle is in the footer):

![wallet connection in forum](/img/tutorials/deforum/wallet-connection-forum.png)

Click "Connect Wallet" and select your wallet of choice. After connecting, you will see a signature
request message that looks similar to the following:

![ceramic session creation in forum](/img/tutorials/deforum/ceramic-auth-forum.png)

Signing this message will create a browser session that the application will reference whenever you
create or edit your data (this removes the necessity to sign individual messages each time you
perform those actions). The OrbisDB SDK will store the result in local storage assigned to the key
`orbis:session`.

If this is your first time logging in, your instance won’t have any pre-existing posts or comments:

![forum home modules](/img/tutorials/deforum/forum-home-modules.png)

The first thing you can do is set up your profile. If you remember back to our table definition for
profiles, the fields you see on this screen are meant to map back to those columns:

![forum profile creation](/img/tutorials/deforum/forum-profile-creation.png)

Try uploading an avatar or a picture of yourself, and create a username, about me section, and name.

When you hit "Save Profile" using an image you’ve uploaded, the corresponding component (mentioned
above) first saves the image to IPFS using the ThirdWeb SDK and stores the resulting image link to
your profile’s row in the table.

![forum profile avatar](/img/tutorials/deforum/profile-avatar.png)

Back on the homepage you should now see your user data populated in the UI:

![forum welcome back](/img/tutorials/deforum/welcome-back-forum.png)

You can now create a post - try creating one with an image asset:

![forum post creation](/img/tutorials/deforum/post-creation.png)

Back on your home page, you should now see this new post appear in the feed:

![forum feed](/img/tutorials/deforum/forum-feed.png)

If you click on one of the posts using the "Thread" button, you will invoke the raw SQL query
covered in the previous section. In a multi-user setting where users are creating comments and
engaging on posts, a given post page might look something like this:

![post thread](/img/tutorials/deforum/post-thread.png)

Finally, if you click on someone’s username, you’ll be navigated to a dynamically-created user page
showing information from their bio, and a list of the different posts that user has created:

![profile related comments](/img/tutorials/deforum/profile-related-comments.png)

## Next Steps

Now that you know how Recall Event Storage (using OrbisDB) can be integrated into a web forum
application to support user data, how might you add features or modifications to improve this demo?
For example, what tables and query patterns would you use to integrate features such as likes on
posts, upvotes, or downvotes? What about direct messages between users? This application can be
improved or extended in numerous ways, so we’re excited to see what you will build!
