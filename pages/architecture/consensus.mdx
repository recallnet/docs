---
title: State machine replication
description: Dig into the consensus mechanisms behind Hoku's state replication.
---

import { Callout } from "nextra/components";

## CometBFT

Within a subnet,
[state machine replication](https://en.wikipedia.org/wiki/State_machine_replication) is achieved via
[CometBFT](https://cometbft.com/) (originally known as
[_Tendermint_](https://atrium.lib.uoguelph.ca/items/5459099e-67aa-4a23-83ae-d3471d8d8336)).
CometBFT's consensus algorithm is based on a variant of
[Practical Byzantine Fault Tolerance](https://dl.acm.org/doi/abs/10.1145/571637.571640) (PBFT) and
relies on a round-robin proposer selection mechanism, while incorporating elements that improve on
PBFT's performance and communication overhead (see also the
[Cosmos whitepaper](https://cosmos.network/resources/whitepaper)). It is a fast, battled-tested, and
well-designed consensus engine.

Hokuâ€™s blockchain functionality is exposed as a unified
[ABCI++](https://members.delphidigital.io/learn/abci) application controlled by CometBFT. ABCI
programs are an interface between CometBFT and the actual state machine being replicated. That is,
ABCIs implement deterministic state machines to be securely replicated by the CometBFT consensus
engine. In this sense, CometBFT acts as a standalone process that issues commands to an underlying
ABCI++ application and exposes a public JSON RPC API, much like the Ethereum JSON RPC API.

<Callout>
The "++" in ABCI++ refers to additional functionality that CometBFT enables compared to the original ABCI, which helps improve the overall scalability and feature surface area.

</Callout>

## Fendermint

Hoku consensus is heavily based on IPC
[Fendermint](https://github.com/consensus-shipyard/ipc/tree/main/fendermint), which is a specialized
ABCI++ interface to the
[Filecoin Virtual Machine](https://docs.filecoin.io/smart-contracts/fundamentals/the-fvm) (FVM) and
Ethereum-compatible FEVM. Fendermint exposes FEVM/FVM-specific functionality within subnets,
allowing Hoku subnets to behave like Filecoin, but with custom parameters to greatly improve
throughput and features.

The unique features of Fendermint include a modified _interpreter stack_ which is responsible for
handling commands from CometBFT. This is a layered series of interpreters that are initialized when
the ABCI++ application is built. Fendermint also includes a _snapshot manager_ that allows
[CAR files](https://ipld.io/specs/transport/car/) to be offered to peers for quick chain sync, and
an _IPLD resolver_ that is used to resolve
[content identifiers (CIDs)](https://docs.ipfs.tech/concepts/content-addressing/#) between peers.
This IPLD resolver is a libp2p-based service that was originally developed to support bottom-up
checkpoints, which are collection of messages from a child subnet that should be executed by parent
validators. In practice, Hoku passes checkpointed headers to its parent and uses the CometBFT ledger
to gather relevant signatures etc., and the parent subnet then leverages the IPLD resolver to fetch
the actual messages and execute them.

<Callout>

It is important to note that the FVM is _not_ the same as Filecoin. The FVM is simply an
IPLD-friendly virtual machine that supports Wasm actors and also EVM compatibility.

</Callout>

## Checkpointing

Checkpointing is how Hoku subnets push data commitments up the hierarchy to the root subnet, as well
as other chains. This check-pointing process is a key component of the hierarchical architecture of
Hoku, and is a core component of the IPC protocol.

Hoku subnets are continuously exchanging data with their parent chain (another subnet or a rootnet
like Filecoin) and (possibly) child subnets, so in addition to bottom-up checkpoints, subnet may
leverage _top-down sync_, when subnets must have a view of their parent finality, which includes the
latest block hash, power table information, and potentially cross-subnet message passing.

## Accounts

Accounts in Hoku are based on standard public-private key pair cryptography, using the ECDSA
algorithm with the [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) curve. This is the same curve
used by Bitcoin and Ethereum, and is widely considered to be secure and efficient. If a user has
access to a private key, they can sign messages sent from that account. The public key is used to
derive an address for the account. Public key addresses are referred to as _robust addresses_ as
they do not depend on the Filecoin chain state.

Accounts are used to send data-carrying transactions, as you would on any blockchain system. Since
Hoku is built on top of the FVM, the addresses derived from public keys follow a slightly different
convention than a purely EVM-based account system. For example, accounts are registered onchain
using the the built-in Ethereum Address Manager (EAM), which manages the Ethereum address space. It
acts like an EVM smart contract _factory_, offering methods to create and assign Filecoin-compatible
addresses to Ethereum addresses. To ease development, Ethereum addresses can be cast as Filecoin
addresses, and vice-versa via default Hoku tooling.

<Callout>

See the
[Filecoin documentation](https://docs.filecoin.io/basics/the-blockchain/addresses#public-keys) for
details on addresses, identifiers, and accounts on the FVM.

</Callout>

In practice, if a user possesses an Ethereum wallet address (starting with `0x`), then the EAM will
assign a corresponding Filecoin-compatible address (prefixed with `f410`) to it. Filecoin addresses
starting with either `f0` or `f410f` can be converted to the `0x` format
[following the Filecoin specification](https://docs.filecoin.io/smart-contracts/filecoin-evm-runtime/address-types#converting-to-a-0x-style-address).
