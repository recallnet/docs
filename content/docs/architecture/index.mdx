---
title: Overview
description: Understand the basics behind what subnets are and how they work.
---

Recall is a decentralized at data network optimized for data-intensive applications. It exposes a
unified data layer backed by a consensus-driven network of actors supporting a fully decentralized,
permissionless, and ownerless architecture. The consensus layer itself is purpose-built to address
the needs of modern data-hungry applications and services, and this design enables a number of
additional innovations, including Recall's _synchronous data synchronization_ mechanism, allowing
the network to ingest large data and files while safeguarding chain liveness.

## Hierarchical structure

The hierarchical nature of Recall also allows it to naturally and logically shard data across
multiple subnets, enabling the network to scale horizontally as demand grows. Additionally, the
arrangement of data and services within unique subnets provides the key substrate upon which
additional innovations can be added.

Recall's decentralized network is developed using the
[Filecoin InterPlanetary Consensus (IPC) framework](https://docs.ipc.space/). IPC is a blockchain
scaling solution and architectural design that is an alternative to existing
[L2 scaling solutions](https://l2beat.com/) and based on the design principles of on-demand
horizontal scaling (similar to traditional web applications).

```mermaid
graph TD
  subgraph Recall
    subgraph Relayer1["Relayer 1"]
      ParentNode1["Parent subnet<br/>node"]
      LightClient1["CometBFT light<br/>client"]
    end
    subgraph Subnet1["Subnet 1"]
      CometBFT1["CometBFT"]
      CometBFT1 --"Consensus"--> CometBFT1
      subgraph ABCI1["Fendermint (ABCI++)"]
        subgraph Machines1["Machines"]
          Bucket1["Bucket"]
          MachineManager1["Machine Manager"]
        end
        ParentView1["Parent View"]
      end
      subgraph IPLD1["IPLD"]
        Store1["Store"]
        Resolver1["Resolver"]
        Store1 <--> Resolver1
      end
      Bucket1 --> Store1
      ABCI1 --> Resolver1
      CometBFT1 --> ABCI1
    end
    subgraph RelayerN["Relayer N"]
      ParentNodeN["Parent subnet<br/>node"]
      LightClientN["CometBFT light<br/>client"]
    end
    subgraph SubnetN["Subnet N"]
      CometBFTN["CometBFT"]
      CometBFTN --"Consensus"--> CometBFTN
      subgraph ABCIN["Fendermint (ABCI++)"]
        subgraph MachinesN["Machines"]
          BucketN["Bucket"]
          MachineManagerN["Machine Manager"]
        end
        ParentViewN["Parent View"]
      end
      subgraph IPLDN["IPLD"]
        StoreN["Store"]
        ResolverN["Resolver"]
        StoreN <--> ResolverN
      end
      BucketN --> StoreN
      ABCIN --> ResolverN
      CometBFTN --> ABCIN
    end
  end
  Root["Rootnet"] <--"Checkpoint"--> Relayer1
  Root <-."Message<br/>passing".-> Relayer1
  Root <-."Message<br/>passing".-> RelayerN
  Root["Rootnet"] <--"Checkpoint"--> RelayerN
  Relayer1 <--"Checkpoint"--> Subnet1
  Relayer1 <-."Message<br/>passing".-> Subnet1
  RelayerN <-."Message<br/>passing".-> SubnetN
  RelayerN <--"Checkpoint"--> SubnetN
```

## Subnet scaling

Traditional blockchains often struggle with scalability as data volume and user base increase, and
Recall tackles this by employing a _subnet_ architecture. This enables parallel processing across
numerous blockchains (subnets), significantly improving throughput.

IPC is designed to enhance performance, decentralization, and security for decentralized
applications by allowing permissionless creation of new blockchain subsystems called subnets. These
subnets are organized hierarchically, enabling seamless internal communication and reducing reliance
on cross-chain bridges, while each can employ its specific consensus algorithm and inherit security
from parent subnets. This structure facilitates hosting or sharding applications based on
performance or cost needs.

Each subnet is associated with exactly one parent. One parent can have many child subnets associated
with it, forming a tree structure. Child subnets periodically checkpoint information to their parent
subnet, and these checkpoints are propagated recursively to the rootnet. This ensures that child
subnets benefit from the security of their parents. Checkpoints cannot be reverted, even if trust is
violated in a child subnet, as long as the parent continues to operate as expected.

Operators of a subnet run a full validator node for both the parent and the child subnet. Requiring
the nodes of child subnets to run the nodes of parents is a security parameter to ensure
checkpointed states of the subnet are appropriately stored, at the right time in the parent. In the
future, Recall subnets will also be able to dynamically adjust their capacity by spawning temporary
subnets during peak usage and merging them during lower activity.
